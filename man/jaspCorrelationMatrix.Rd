% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/correlationMatrix.R
\name{jaspCorrelationMatrix}
\alias{jaspCorrelationMatrix}
\title{Correlation matrix plot}
\usage{
jaspCorrelationMatrix(
  data,
  diagonal = jaspHistogram,
  diagonalArgs = list(density = TRUE),
  topRight = jaspScatter,
  topRightArgs = list(suppressAxesLabels = TRUE),
  bottomLeft = NULL,
  bottomLeftArgs = list(),
  overwriteDiagonalAxes = "x",
  overwriteTopRightAxes = "both",
  overwriteBottomLeftAxes = "both",
  patch = TRUE
)
}
\arguments{
\item{data}{Data frame of data to plot.}

\item{diagonal}{A function that draws the plots on the diagonal. Must accept arguments \code{x} (numeric), \code{xName} (character).}

\item{diagonalArgs}{A list of additional arguments to pass to \code{diagonal}.}

\item{topRight}{A function that draws the plots on the top right off-diagonal. Must accept arguments \code{x} (numeric), \code{y} (numeric), \code{xName} (character), and \code{yName} (character).}

\item{topRightArgs}{A list of additional arguments to pass to \code{topRight}.}

\item{bottomLeft}{A function that draws the plots on the bottom left off-diagonal. Must accept arguments \code{x} (numeric), \code{y} (numeric), \code{xName} (character), and \code{yName} (character).}

\item{bottomLeftArgs}{A list of additional arguments to pass to \code{bottomLeft}.}

\item{overwriteDiagonalAxes, overwriteTopRightAxes, overwriteBottomLeftAxes}{Which axes should be overwritten such that they have a common range. Possible options:
\describe{
\item{\code{"none"}}{No axes are overwritten, hence the plots get their own scales given by \code{diagonal}, \code{topRight}, and \code{bottomLeft} functions, respectively.}
\item{\code{"both"}}{Both axes are overwritten. The plots inherit scales by setting their \code{breaks} determined by \link{getPrettyAxisBreaks}, and the plotting region is set by \link[ggplot2:coord_cartesian]{ggplot2::coord_cartesian} with \code{limits} set to \code{range(breaks)}. Further, the name of the axis is set to \code{NULL}.}
\item{\code{"x"}}{x-axis gets overwritten (see option \code{"both"}), y-axis does not (see option \code{"none"}).}
\item{\code{"y"}}{y-axis gets overwritten (see option \code{"both"}), x-axis does not (see option \code{"none"}).}
}}

\item{patch}{Logical; if \code{TRUE}, the plot object is returned, otherwise an object of class \code{jaspGraphsPlot} is returned.}
}
\description{
Plot that consists of \code{ncol{data}} by \code{ncol{data}} plots,
where subplot on position \eqn{(i, j)} plots \code{data[, c(i, j)]}.
The plot can display three different types of plots:
\describe{
\item{\code{diagonal}}{Where \code{i == j}.}
\item{\code{topRight}}{Where \code{i < j}.}
\item{\code{bottomLeft}}{Where \code{i > j}.}
}
}
\examples{
# generate correlated data
set.seed(1)
x <- matrix(rnorm(3*1000), ncol = 3)
ch <- structure(c(1, 0, 0, 1.5, 5, 0, 5, -8, 10), dim = c(3L, 3L))
df <- as.data.frame(x \%*\% ch)
colnames(df) <- c("apples", "oranges", "wine")

# default plot
jaspCorrelationMatrix(data = df)


# custom plotting function with a complicated results object
# (example of jaspRegression/correlation)
pairs <- combn(colnames(df), 2, simplify = FALSE)
pairNames <- sapply(pairs, paste0, collapse = "", simplify = TRUE)

results <- lapply(pairs, function(variables) {
  cor.test(df[[variables[1]]], df[[variables[2]]])
})
names(results) <- pairNames

plotCorStats <- function(x, y, xName, yName, results, options) {
  pairName <- paste0(xName, yName)
  res <- results[[pairName]]

  est <- paste0("r = ", signif(res$estimate, 3))
  ci  <- sprintf("\%i\%\% CI = [\%.3f,\%.3f]", 100*options[["ciLevel"]], res$conf.int[1], res$conf.int[2])
  plot <- ggplot2::ggplot() +
    ggplot2::theme_void() +
    ggplot2::scale_x_continuous(limits = 0:1) +
    ggplot2::scale_y_continuous(limits = 0:1) +
    ggplot2::geom_text(
      data = data.frame(x = 0.5, y = c(0.7, 0.3), label = c(est, ci)),
      mapping = ggplot2::aes(x = x, y = y, label = label),
      parse = FALSE,
      size = jaspGraphs::getGraphOption("fontsize") / ggplot2::.pt
    )

  return(plot)
}

jaspCorrelationMatrix(
  data           = df,
  bottomLeft     = plotCorStats,
  bottomLeftArgs = list(results = results, options = list(ciLevel = 0.95)),
  topRightArgs   = list(smooth = "lm", smoothCi = TRUE, predict = "ellipse")
)


# group example (jags)
chains <- 3
iter   <- 500
chain <- gl(chains, iter)
df <- data.frame(
  mu    = rnorm(chains*iter, as.integer(chain)),
  sigma = rgamma(chains*iter, shape = as.integer(chain), rate = 1/as.integer(chain))
)

jaspCorrelationMatrix(
  data = df,
  diagonalArgs = list(
    groupingVariable     = chain,
    groupingVariableName = "chain",
    histogramPosition    = "identity",
    density              = FALSE,
    rugs                 = TRUE
  ),
  topRightArgs = list(type = "hex")
)


# or display a trace plot on the diagonal
tracePlot <- function(x, xName, iter, chain) {
  ggplot2::ggplot(data = data.frame(x = x, chain = chain, iter = iter)) +
    ggplot2::geom_line(ggplot2::aes(x = iter, y = x, color = chain, group = chain)) +
    jaspGraphs::themeJaspRaw() +
    jaspGraphs::geom_rangeframe() +
    ggplot2::xlab("Iteration")
}

jaspCorrelationMatrix(
  data                  = df,
  diagonal              = tracePlot,
  diagonalArgs          = list(
    chain = chain,
    iter  = rep(seq_len(iter), times = chains)
  ),
  topRightArgs          = list(type = "hex", bins = 10, palette = "viridis"),
  bottomLeft            = jaspScatter,
  bottomLeftArgs        = list(type = "hex", bins = 10, palette = "viridis"),
  overwriteDiagonalAxes = "y"
)
}
